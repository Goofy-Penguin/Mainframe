# ptalk

An api library that allows for 2-way communication between a client and a server.

## table of contents
1. [how does it work](#how-does-it-work)
2. [how do i use it](#how-do-i-use-it)
    1. [server](#server)
    2. [client](#client)

## how does it work

The protocol sends messages 2-way containing a `method name` for calling an method on the other end, and an `id` to reply and keep track of an conversation.

Every `tcp packet` contains of 4 variables.

- `uint32_t` packet size excluding itself
- `uint32_t` id of the message used for replying
- `uint16_t:string` method name it wants to invoke
- `uint32_t:bson` payload of the message generated by `nlohmann::json::to_bson`

When the `method name` is empty, the message is an reply.
If the user provided a callback at the `client->send("method", {json}, callback)` the reply callback is called.

#### note

When using reply more than once as a conversation, on the client side where you connect to the server you will have to create it as `std::shared_ptr<Client> client` and do `client->setRef(client)` on it.
This is so that the `client` can keep track of itself and doesn't start calling unallocated memory.
In the future I'd like to see this solved inside of the library itself.

## how do i use it

#### server

```C++
// includes for this example
#include <mainframe/ptalk/server.h>
#include <mainframe/ptalk/client.h>
#include <mainframe/ptalk/messageincomming.h>
#include <fmt/printf.h>


// create the object
mainframe::ptalk::Server server;

// listen on port 5028
if (!server.listen(5028)) {
	return false;
}

// add an event to handle when a client connects
server.onClient += [](std::shared_ptr<Client> client) {
	// register a global message hook that gets fires before methods are called
	client->onMessage += [client](MessageIncomming& msg) {
		std::string ip = inet_ntoa(client->getSocket().addr.sin_addr);
		fmt::print("recieved '{}' from '{}'\n", msg.getName(), ip);
	};

	// register methods
	client->addMethod("methodName", [](MessageIncomming& msg) {
		uint32_t uid = msg.getId();
		const std::string& name = msg.getName();
		nlohmann::json data = msg.getData()

		// reply to the message with a `nlohmann::json` object
		msg->reply({{"beep", "boop"});
	}

	// send a message with a `nlohmann::json` object
	client->send("methodName", {{"beep", "boop"});
}

// stop the server with its threads, also done at Server::~Server
server.close();
```

#### client

```C++
// includes for this example
#include <mainframe/ptalk/client.h>
#include <mainframe/ptalk/messageincomming.h>
#include <fmt/printf.h>

// create the object
auto client = std::make_shared<mainframe::ptalk::Client>();

// set the internal ref so that we can use conversations
client->setRef(client);

// connect to 5028
if (client->connect("127.0.0.1", 5028) != SocketError::success) {
	return false;
}

// register a global message hook that gets fires before methods are called
client->onMessage += [](MessageIncomming& msg) {
	fmt::print("recieved '{}' from server\n", msg.getName());
};

// register methods
client->addMethod("methodName", [](MessageIncomming& msg) {
	uint32_t uid = msg.getId();
	const std::string& name = msg.getName();
	nlohmann::json data = msg.getData()

	// reply to the message with a `nlohmann::json` object
	msg->reply({{"beep", "boop"});
}

// send a message with a `nlohmann::json` object
client->send("methodName", {{"beep", "boop"});

// close the client, also done at Client::~Client()
client->close();
```
